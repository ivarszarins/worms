<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<style>
		html,
		body {
			height: 100%;
			width: 100%;
			margin: 0;
		}

		#gameCanvas {
			display: block;
			height: 100%;
			width: 100%;
			margin: 0;
		}
	</style>
</head>

<body>
	<canvas id="gameCanvas"></canvas>

	<script>
		/*
		place random goody
		if eat goody, make body longer
		collision with body means game over
		 */

		const WORM_GAME = (() => {
			function Worm(startPoint, startDirection, startSize) {
				this.arr = new Array(100);
				this.head = startSize-1;
				this.tail = 0;

				// initialize worm
				const dx = startDirection == directions.RIGHT ? -1 : startDirection == directions.LEFT ? 1 : 0;
				const dy = startDirection == directions.DOWN ? -1 : startDirection == directions.UP ? 1 : 0;
				[...Array(startSize).keys()].map(i => this.arr[this.head-i] = { x: startPoint.x + dx * i, y: startPoint.y + dy * i });

				this.move = (direction) => {
					const dx = direction == directions.RIGHT ? 1 : direction == directions.LEFT ? -1 : 0;
					const dy = direction == directions.DOWN ? 1 : direction == directions.UP ? -1 : 0;
					oldHead = this.arr[this.head];

					this.advanceHead();
					this.advanceTail();

					newHead = this.arr[this.head] = { x: oldHead.x + dx, y: oldHead.y + dy };

					// detect edges
					if (newHead.x >= columns) {
						newHead.x = 0;
					} else if (newHead.x <= 0) {
						newHead.x = columns - 1;
					} else if (newHead.y >= rows) {
						newHead.y = 0;
					} else if (newHead.y <= 0) {
						newHead.y = rows - 1;
					}
				};

				this.advanceHead = () => this.head = this.head == this.arr.length -1 ? 0 : this.head += 1;
				this.advanceTail = () => this.tail = this.tail == this.arr.length -1 ? 0 : this.tail += 1;

				this.getIterator = function*() {
					if (this.head > this.tail) {
						for(let i = this.head; i >= this.tail; i--) {
							yield this.arr[i];
						}
					} else {
						for(let i = this.head; i >= 0; i--) {
							yield this.arr[i];
						}
						for(let i = this.arr.length-1; i >= this.tail; i--) {
							yield this.arr[i];
						}
					}
				};

				this.draw = () => {
					let iter = this.getIterator();
					let result = iter.next();
					console.log("drawing head", result.value);
					while(!result.done) {
						ctx.fillRect(result.value.x * segmentSize, result.value.y * segmentSize, segmentSize, segmentSize);
						result = iter.next();
					}
				};
			}

			const directions = { UP: 'UP', DOWN: 'DOWN', RIGHT: 'RIGHT', LEFT: 'LEFT' };
			const gameCanvas = document.getElementById("gameCanvas");
			const ctx = gameCanvas.getContext("2d");
			const segmentSize = 20;
			let maxWidth = window.innerWidth;
			let maxHeight = window.maxHeight;
			let	rows = maxHeight / segmentSize;
			let	columns = maxWidth / segmentSize;
			let gameOver = false;
			let direction = directions.RIGHT;

			let worm = new Worm({ x: 10, y:10}, directions.RIGHT, 80);

			document.addEventListener("keyup", e => {
				if (e.key == "Right" || e.key == "ArrowRight" || e.key == "l") {
					direction = turnRight();
					worm.move(direction);
				}
				else if (e.key == "Left" || e.key == "ArrowLeft" || e.key == "h") {
					direction = turnLeft();
					worm.move(direction);
				}
			}, false);

			turnRight = () => {
				switch (direction) {
					case directions.UP: return directions.RIGHT;
					case directions.RIGHT: return directions.DOWN;
					case directions.DOWN: return directions.LEFT;
					case directions.LEFT: return directions.UP;
				}
			};

			turnLeft = () => {
				switch (direction) {
					case directions.UP: return directions.LEFT;
					case directions.RIGHT: return directions.UP;
					case directions.DOWN: return directions.RIGHT;
					case directions.LEFT: return directions.DOWN;
				}
			};

			var draw = () => {
				ctx.canvas.width = maxWidth = window.innerWidth;
				ctx.canvas.height = maxHeight = window.innerHeight;

				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

				rows = maxHeight / segmentSize;
				columns = maxWidth / segmentSize;

				worm.move(direction);
				worm.draw(ctx);

				// detectEdges();

				if (gameOver == false) {
					requestAnimationFrame(draw);
				}
			}

			var run = () => draw();

			return {
				run: run
			}
		})();

		WORM_GAME.run();
	</script>
</body>

</html>
