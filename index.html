<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
        <style>
            html,body {
                height: 100%;
                width: 100%;
                margin: 0;
            }
            #gameCanvas {
                display: block;
                height: 100%;
                width: 100%;
                margin: 0;
            }
        </style>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>

        <script>
            /*
            keep track of whole body
            place random goody
            if eat goody, make body longer
            collision with body means game over
            */
            var WORM = (() => {
                const directions = { UP: 'UP', DOWN: 'DOWN', RIGHT: 'RIGHT', LEFT: 'LEFT' };
                const gameCanvas = document.getElementById("gameCanvas");
                const ctx = gameCanvas.getContext("2d");
                const segmentSize = 10;
                let maxWidth = window.innerWidth;
                let maxHeight = window.maxHeight;
                let gameOver = false;
                let direction = directions.RIGHT;
                let r = { x: 10, y: 10};

                let worm = [{x: 10, y: 10}, {x: 0, y:10}];
                let headIndex = 0;
                let length = 2;

                document.addEventListener("keyup", e => {
                    if(e.key == "Right" || e.key == "ArrowRight" || e.key == "l") {
                        direction = turnRight();
                    }
                    else if (e.key == "Left" || e.key == "ArrowLeft" || e.key == "h") {
                        direction = turnLeft();
                    }
                }, false);

                turnRight = () => {
                    switch (direction) {
                        case directions.UP: return directions.RIGHT;
                        case directions.RIGHT: return directions.DOWN;
                        case directions.DOWN: return directions.LEFT;
                        case directions.LEFT: return directions.UP;
                    }
                };

                turnLeft = () => {
                    switch (direction) {
                        case directions.UP: return directions.LEFT;
                        case directions.RIGHT: return directions.UP;
                        case directions.DOWN: return directions.RIGHT;
                        case directions.LEFT: return directions.DOWN;
                    }
                };

                var detectEdges = () => {
                    if (worm[0].x >= maxWidth) {
                        worm[0].x = 0;
                        return;
                    }
                    if (worm[0].x <= 0) {
                        worm[0].x = maxWidth-segmentSize;
                        return;
                    }
                    if (worm[0].y >= maxHeight) {
                        worm[0].y = 0;
                        return;
                    }
                    if (worm[0].y <= 0) {
                        worm[0].y = maxHeight-segmentSize;
                        return;
                    }
                };

                var draw = () => {
                    ctx.canvas.width = maxWidth = window.innerWidth;
                    ctx.canvas.height = maxHeight =window.innerHeight;

                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                    worm[1].x = worm[0].x;
                    worm[1].y = worm[0].y;

                    switch (direction) {
                        case directions.UP: worm[0].y -= segmentSize; break;
                        case directions.RIGHT: worm[0].x += segmentSize; break;
                        case directions.DOWN: worm[0].y += segmentSize; break;
                        case directions.LEFT: worm[0].x -= segmentSize; break;
                    }

                    for (i = 0; i< worm.length; i++) {
                        ctx.fillRect(worm[i].x, worm[i].y, segmentSize, segmentSize);
                    }

                    detectEdges();

                    if (gameOver == false) {
                        requestAnimationFrame(draw);
                    }
                }

                var run = () => draw();

                return {
                    run: run
                }
            })();

            WORM.run();
        </script>
    </body>
</html>